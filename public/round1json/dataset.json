[
  {
    "questionid": "1",
    "difficulty": "Easy",
    "description":"<p>&nbsp;Given an expression string <strong>x</strong>. Examine whether the pairs and the orders of &ldquo;{&ldquo;,&rdquo;}&rdquo;,&rdquo;(&ldquo;,&rdquo;)&rdquo;,&rdquo;[&ldquo;,&rdquo;]&rdquo; are correct in exp.<br />For example, the function should return 'true' for exp = &ldquo;[()]{}{[()()]()}&rdquo; and 'false' for exp = &ldquo;[(])&rdquo;.<strong><br /><br><hr>Input Guide :</strong><br> Insert you answer(which will be string ) without quotes like :<strong>{ ( [ ] ) }</strong> . <br></p><br></br><hr><p><strong>Example 1:</strong></p><strong>Input</strong>   :  {([])}<br><strong>Output </strong> :  true<br><strong>Explanation</strong> : { ( [ ] ) }.&nbsp;Same kind of brackets can form balaced pairs, with <br>0 number of unbalanced bracket.<p></p></p><p><br><hr><strong>Exapmle 2 :</strong><br><strong>Input</strong> : ()<br><strong>Output </strong> : true<br><strong>Explanation </strong> : (). Same bracket can form balanced pairs,and here <br>only 1 type of bracket is present and in<br>balanced way<p></p><br><hr><p><strong>Example 3:</strong></p><strong>Input </strong> : ([]<br><strong>Output  </strong> : false<br><strong>Explanation </strong> : ([]. Here square bracket is balanced but the<br> small bracket is not balanced and <br>Hence , the output will be unbalanced.<p></p><br><hr><strong>Constraints:</strong><br />1 &le; |x| &le; 32000<p></p></p>",    "wrongcodefile": "1wrongcode.cpp",
    "rightcodefile": "1rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\n\n\nclass Solution\n{\n    public:\n    bool ispar(string x)\n    {\n        stack<int> s;\n        int i=0;\n        while(i<x.size()){\n            if(x[i]=='('||x[i]=='{'||x[i]=='['){\n                if(x[i]=='('){\n                    s.push(-1);\n                }\n                if(x[i]=='['){\n                    s.push(0);\n                }\n                if(x[i]=='{'){\n                    s.push(1);\n                }\n            }\n            else{\n                if(s.size()==0){\n                    return false;\n                }\n                else{\n                    if(x[i]==')'&&s.top()!=-1){\n                        return false;\n                    }\n                    if(x[i]==']'&&s.top()!=0){\n                        return false;\n                    }\n                    if(x[i]=='}'&&s.top()!=1){\n                        return false;\n                    }\n                    s.pop();\n                }\n            }\n            i++;\n        }\n\n        return true;\n    }\n\n};\n\n\nint main()\n{\n   string a;\n       cin>>a;\n       Solution obj;\n       if(obj.ispar(a))\n        cout<<\"balanced\"<<endl;\n       else\n        cout<<\"not balanced\"<<endl;\n}",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\n\nclass Solution\n{\n    public:\n    bool ispar(string x)\n    {\n        stack<int> s;\n        int i=0;\n        while(i<x.size()){\n            if(x[i]=='('||x[i]=='{'||x[i]=='['){\n                if(x[i]=='('){\n                    s.push(-1);\n                }\n                if(x[i]=='['){\n                    s.push(0);\n                }\n                if(x[i]=='{'){\n                    s.push(1);\n                }\n            }\n            else{\n                if(s.size()==0){\n                    return false;\n                }\n                else{\n                    if(x[i]==')'&&s.top()!=-1){\n                        return false;\n                    }\n                    if(x[i]==']'&&s.top()!=0){\n                        return false;\n                    }\n                    if(x[i]=='}'&&s.top()!=1){\n                        return false;\n                    }\n                    s.pop();\n                }\n            }\n            i++;\n        }\n        if(s.empty()){\n            return true;\n        }\n        return false;\n    }\n\n};\n\n\nint main()\n{\n   string a;\n       cin>>a;\n       Solution obj;\n       if(obj.ispar(a))\n        cout<<\"balanced\"<<endl;\n       else\n        cout<<\"not balanced\"<<endl;\n}"
  },
  {
    "questionid": "2",
    "difficulty": "Hard",
    "description":"Given a string <strong>S</strong> consisting of only opening and closing curly brackets<strong> '{'</strong> and<strong> '}',</strong>&nbsp;find out the minimum&nbsp;number of reversals required to convert the string into a balanced expression.<br />A reversal means changing <strong>'{'</strong> to <strong>'}'</strong> or vice-versa.<p><strong><br /><hr>Input Guide :</strong><br> Insert you ans (which will be string ) without quotes like: <strong> {{{}}}}}</strong> . <br></p></p><br><hr><p>Example 1&nbsp;:</strong><strong><br>Input&nbsp;:&nbsp;</strong>S = <strong>{&nbsp;{&nbsp;{&nbsp;}&nbsp;}&nbsp;{&nbsp;{&nbsp;{</strong><strong><br>Output&nbsp;:&nbsp;</strong>&nbsp; 2<strong><br>Explanation</strong>&nbsp;:&nbsp;<br> One way to balance is:<strong>{&nbsp;</strong>{&nbsp;{&nbsp;}&nbsp;}&nbsp;<strong>{&nbsp;}&nbsp;}</strong>. There is no balanced sequence that can be formed in lesser reversals.<br><hr><strong>Exapmle&nbsp; :&nbsp;2 <br>Input</strong>&nbsp;:&nbsp;S = {&nbsp;{&nbsp;}&nbsp;{&nbsp;{&nbsp;{&nbsp;}&nbsp;{&nbsp;{&nbsp;}&nbsp;}&nbsp;{&nbsp;{&nbsp;<strong><br>Output:</strong> -1<strong><br>Explanation</strong>: There's no way we can balancethis sequence of braces.<br><hr><p><strong>Expected Time Complexity:&nbsp;</strong>O(|S|).<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</p><p><strong>Constraints:</strong><br />1 &le; |S| &le; 10<sup>5</sup></p>",    "wrongcodefile": "2wrongcode.cpp",
    "rightcodefile": "2rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nint countRev (string s);\n\nint main()\n{\n    string s; \n    cin >> s;\n    cout << countRev (s) << '\\n';\n}\n\nint countRev (string s)\n{\n    stack<char> st;\n    if(s.size()%2!=0){\n        return -1;\n    }\n    for(int i=0;i<s.size();i++){\n        if(st.empty()){\n            st.push(s[i]);\n        }\n        else{\n            if(st.top()=='{'&&s[i]=='}'){\n                st.pop();\n            }else{\n                st.push(s[i]);\n            }\n        }\n    }\n\n    return st.size()/2;\n}",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nint countRev (string s);\n\nint main()\n{\n    string s; \n    cin >> s;\n    cout << countRev (s) << '\\n';\n}\n\nint countRev (string s){\n    stack<char> st;\n\n    if(s.size()%2!=0){\n        return -1;\n    }\n\n    for(int i=0;i<s.size();i++){\n        if(st.empty()){\n            st.push(s[i]);\n        }\n        else{\n            if(st.top()=='{'&&s[i]=='}'){\n                st.pop();\n            }else{\n                st.push(s[i]);\n            }\n        }\n    }\n\n    int count=0;\n\n    while(!st.empty()){\n        char top=st.top();\n        st.pop();\n        if(st.top()==top){\n            count=count+1;\n        }\n        else{\n           count= count+2;\n        }\n        st.pop();\n    }\n    return count;\n}"
  },
  {
    "questionid": "3",
    "difficulty": "Easy",
    "description":"<p>Given a string<strong> S </strong>delete the characters which are appearing more than once consecutively.</p><strong><br /><hr>Input Guide :</strong><br> Insert you ans (which will be string ) without quotes like : <strong>aacbdd </strong>. <br></p><br><hr><br><p><strong>Example 1:</strong></p><strong>Input:</strong>S = aabb<strong><br>Output:  </strong>ab <strong><br>Explanation:<br></strong> 'a' at 2nd position isappearing 2nd time consecutively.Similiar explanation for b at 4th position.<br><br><hr><br><p><strong>Example 2:</strong><strong><br>Input</strong> : S = aabaa<strong><br>Output:</strong>  aba <strong><br>Explanation:</strong> 'a' at 2nd position is appearing 2nd time consecutively.'a' at fifth position is appearing 2nd time consecutively.</p><p><strong><br><hr><br>GUID:</strong><br />Code starts from&nbsp; the function <strong>removeConsecutiveCharacter()</strong> which accepts a string as input parameter and <strong>returns</strong> modified string. try and find out a (there could be many) invalid test case which will not work out with this solution for current question&nbsp;</p><p><strong><br><hr>Constraints:</strong><br />1&lt;=|S|&lt;=10<sup>5</sup><br />All characters are lowercase alphabets.</p>",    "wrongcodefile": "3wrongcode.cpp",
    "rightcodefile": "3rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack> \nusing namespace std; \n\n\nclass Solution{\n    public:\n    void helper(string& S, int index,string& ans){\n        if(index==S.size()-1){\n            if(S[index]==S[index-1]){\n                ans.push_back(S[index]);\n            }\n            return;\n        }\n        if(index==S.size()-1){\n            ans.push_back(S[index]);\n            return;\n        }\n        if(S[index]==S[index+1]){\n            helper(S,index+1,ans);\n        }\n        else{\n            ans.push_back(S[index]);\n            helper(S,index+1,ans);\n            return ;\n        }\n    }\n    string removeConsecutiveCharacter(string S)\n    {\n        string ans;\n         helper(S,0,ans);\n         return ans;\n    }\n};\n\n\nint main() \n{ \n        string s;\n        cin>>s;\n        Solution ob;\n        cout<<ob.removeConsecutiveCharacter(s)<<endl;\n} ",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std; \n\n\n\nclass Solution{\n    public:\n    void helper(string& S, int index,string& ans){\n        if(index==S.size()-1){\n            ans.push_back(S[index]);\n            return;\n        }\n        if(S[index]==S[index+1]){\n            helper(S,index+1,ans);\n        }\n        else{\n            ans.push_back(S[index]);\n            helper(S,index+1,ans);\n            return ;\n        }\n    }\n    string removeConsecutiveCharacter(string S)\n    {\n        string ans;\n         helper(S,0,ans);\n         return ans;\n    }\n};\n\n\nint main() \n{ \n        string s;\n        cin>>s;\n        Solution ob;\n        cout<<ob.removeConsecutiveCharacter(s)<<endl;\n} "
  },
  {
    "questionid": "4",
    "difficulty": "Hard",
    "description":"<p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p><ul><li>For example, <code>&quot0.1.2.201&quot</code> and <code>&quot192.168.1.1&quot</code> are <strong>valid</strong> IP addresses, but <code>&quot0.011.255.245&quot</code>, <code>&quot192.168.1.312&quot</code> and <code>&quot192.168@1.1&quot</code> are <strong>invalid</strong> IP addresses.</li></ul><p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into </em><code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p><strong><br /><hr>Input Guide :</strong><br> Insert you ans (which will be numeric string ) without quotes <br>like : <strong>2344567</strong>   . <br></p><br><hr><p><strong>Example 1:</strong></p><p><strong>Input:</strong> s = &quot25525511135&quot</p><strong>Output:</strong> [&quot255.255.11.135&quot,&quot255.255.111.35&quot]<p><strong><br><hr>Example 2:</strong></p><p><strong>Input:</strong> s = &quot1111&quot</p><p><strong>Output:</strong> [&quot1.1.1.1&quot]</p><br><hr><p><strong>Example 3:</strong></p><p><strong>Input:</strong> s = &quot144&quot</p><p><strong>Output:</strong> [&quot&quot]</p><p><strong>Explanation: size of string is less than 4 so it could not be converted into a valid IP .</strong></p><p><strong></strong></p><p><strong><br><hr>Example 4:</strong></p><p><strong>Input:</strong> s = &quot74574377238232&quot</p><p><strong>Output:</strong> [&quot&quot]</p><p><strong>Explanation: size of string is less greater than 12 so it could not be converted into a valid IP .</strong></p><p><strong></strong></p>",    "wrongcodefile": "4wrongcode.cpp",
    "rightcodefile": "4rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> ans;\n    bool valid(string s){\n        if(s[0]=='0'){\n            return false;\n        }\n        int v=stoi(s);\n        if(v>255){\n            return false;\n        }\n        return true;\n    }\n    void helper(string &s,int i,int part,string res){\n        if(s.size()==i||part==4){\n            if(s.size()==i&&part==4){\n                ans.push_back(res.substr(0,res.size()-1));\n                return;\n            }\n            return;\n        }\n        if(s.size()-i>=1&&valid(s.substr(i,1))){\n              helper(s,i+1,part+1,res+s[i]+\".\");\n        }\n        if(s.size()-i>=2&&valid(s.substr(i,2))){\n              helper(s,i+2,part+1,res+s.substr(i,2)+\".\");\n        }\n        if(s.size()-i>=3&&valid(s.substr(i,3))){\n              helper(s,i+3,part+1,res+s.substr(i,3)+\".\");\n        }\n        return;\n    }\n    vector<string> restoreIpAddresses(string s) {\n        helper(s,0,0,\"\");\n        return ans;\n    }\n};\n\nint main(){\n    string s;\n    cin>>s;\n    vector<string>v;\n    Solution ob;\n    v=ob.restoreIpAddresses(s);\n    int n=v.size();\n    for(int i=0;i<n;i++){\n        cout<<v[i];\n    }\n    cout<<endl;\n    return 0;\n}",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> ans;\n    bool valid(string s){\n        if(s[0]=='0'){\n            return false;\n        }\n        int v=stoi(s);\n        if(v>255){\n            return false;\n        }\n        return true;\n    }\n    void helper(string &s,int i,int part,string res){\n        if(s.size()==i||part==4){\n            if(s.size()==i&&part==4){\n                ans.push_back(res.substr(0,res.size()-1));\n                return;\n            }\n            return;\n        }\n\n        helper(s,i+1,part+1,res+s[i]+\".\");\n        \n        if(s.size()-i>=2&&valid(s.substr(i,2))){\n              helper(s,i+2,part+1,res+s.substr(i,2)+\".\");\n        }\n        \n        if(s.size()-i>=3&&valid(s.substr(i,3))){\n              helper(s,i+3,part+1,res+s.substr(i,3)+\".\");\n        }\n        return;\n    }\n    vector<string> restoreIpAddresses(string s) {\n        helper(s,0,0,\"\");\n        return ans;\n    }\n};\n\n\nint main(){\n    string s;\n    cin>>s;\n    vector<string>v;\n    Solution ob;\n    v=ob.restoreIpAddresses(s);\n    int n=v.size();\n    for(int i=0;i<n;i++){\n        cout<<v[i];\n    }\n    cout<<endl;\n    return 0;\n}"
  },
  {
    "questionid": "5",
    "difficulty": "Hard",
    "description":"<p>&nbsp;</p><p>A parentheses string is a <strong>non-empty</strong> string consisting only of '(' and ')'. It is valid if <strong>any</strong> of the following conditions is <strong>true</strong>:</p><ul><li>It is ().</li><li>It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.</li><li>It can be written as (A), where A is a valid parentheses string.</li></ul><p>You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For <strong>each</strong> index i of locked,</p><ul><li>If locked[i] is '1', you <strong>cannot</strong> change s[i].</li><li>But if locked[i] is '0', you <strong>can</strong> change s[i] to either '(' or ')'.</li></ul><p>Return true <em>if you can make s a valid parentheses string</em>. Otherwise, return false.</p><p><strong><br /><hr>Input Guide :</strong><br> insert the string s in first line without qoutes then in the second line insert string 2 (numeric string) like : <strong><br> ))())) <br> 010110  <br></p></p><br><hr><br><strong>Example 1:</strong><strong><br>Input:</strong> s = &quot;))()))&quot;, locked = &quot;010100&quot;<strong><br>Output:</strong> true<strong><br>Explanation:</strong> locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.<br><br><hr><br><p><strong>Example 2:</strong> <strong><br>Input:</strong> s = &quot;()()&quot;, locked = &quot;0000&quot; <strong><br>Output:</strong> true <strong><br>Explanation:</strong> We do not need to make any changes because s is already valid.</p><br><hr><strong>Example 3:</strong><strong><br>Input:</strong> s = &quot;)&quot;, locked = &quot;0&quot;<strong><br>Output:</strong> false<strong><br>Explanation:</strong> locked permits us to change s[0]. Changing s[0] to either '(' or ')' will not make s valid.<br><br><hr><br><p><strong>Constraints:</strong></p><ul><li><code>n == s.length == locked.length</code></li><li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code>s[i]</code> is either <code>'('</code> or <code>')'</code>.</li><li><code>locked[i]</code> is either '0' or 1'.</li></ul>",    "wrongcodefile": "5wrongcode.cpp",
    "rightcodefile": "5rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nclass Solution {\n    public:\n        bool canBeValid(string s, string l) {\n        stack<int>st;\n        int n=s.size();\n        if(n%2!=0){\n            return false;\n        }\n        for(int i=0;i<n;i++){\n            if(s[i]==')'&&!st.empty()&&s[st.top()]=='('){\n                st.pop();\n                continue;\n            }\n            else{\n                st.push(i);\n            }\n        }\n        if(st.size()%2!=0){\n            return false;\n        }\n        while(!st.empty()){\n            char a=s[st.top()];\n            int i=st.top();\n            st.pop();\n            char b=s[st.top()];\n            int j=st.top();\n            if(a==b){\n                if(a=='('){\n                    if(l[i]!='0'||l[j]!='0'){\n                        return false;\n                    }\n                }\n                else{\n                     if(l[j]!='0'){\n                        return false;\n                    }\n                }\n            }\n            else{\n                if(l[j]!='0'){\n                    return false;\n                }\n            }\n            st.pop();\n        }\n        return true;\n    }\n};\nint main() {\n    \n    string s;\n    cin>>s;\n    string l;\n    cin>>l;\n    Solution ob;\n    cout<<ob.canBeValid(s,l)<<endl;\n} ",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nclass Solution {\npublic:\n     bool canBeValid(string s, string l) {\n         int n=s.size();\n         if(n%2!=0){\n             return false;\n         }\n         int e=0;\n         int b=0;\n         for(int i=0;i<n;i++){\n             if(l[i]=='0'){\n                 e++;\n             }\n             else{\n                 b+=(s[i]=='(' ? 1 : -1);\n                 if(b==-1){\n                     b=0;\n                     if(e==0){\n                         return false;\n                     }\n                     else{\n                         e++;\n                     }\n                 }\n             }\n         }\n         e=0;\n         b=0;\n         for(int i=n-1;i>=0;i--){\n             if(l[i]=='0'){\n                 e++;\n             }\n             else{\n                 b+=(s[i]==')' ? 1:-1);\n                 if(b==-1){\n                     b=0;\n                     if(e==0){\n                         return false;\n                     }\n                     else{\n                         e--;\n                     }\n                 }\n             }\n         }\n         return true;\n\n    }\n};\nint main() \n{ \n    string s;\n    cin>>s;\n    string l;\n    cin>>l;\n    Solution ob;\n    cout<<ob.canBeValid(s,l)<<endl;\n} "
  },
  {
    "questionid": "6",
    "difficulty": "Medium",
    "description":"<p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p><p>&nbsp;</p><strong><br /><hr>Input Guide :</strong><br> Insert you answer (which will be tree) you have to <br> insert tree in inline where nodes are separed by white spaces  <br> and non existing nodes(null node) will be inserted as N <br> like : <strong>1 2 3 N 4 5 6 </strong>(recursive input) . <br></p><p><strong><br><hr>Example 1:</strong></p><br /><strong>Input:</strong> root = 3 9 20 N N 15 7<strong><br>Output:</strong> 2<p><strong><br><hr>Example 2:</strong></p><strong>Input:</strong> root = 2 N 3 N 4 N 5 N 6<strong><br>Output:</strong> 5<p>&nbsp;</p><p><strong><br>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div>",    "wrongcodefile": "6wrongcode.cpp",
    "rightcodefile": "6rightcode.cpp",
    "wrongcode": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node\n{\n    int data;\n    struct Node *left;\n    struct Node *right;\n\n    Node(int val) {\n        data = val;\n        left = right = NULL;\n    }\n}; \n\nNode* buildTree(string str)\n{   \n    if(str.length() == 0 || str[0] == 'N')\n        return NULL;\n    \n    vector<string> ip;\n    \n    istringstream iss(str);\n    for(string str; iss >> str; )\n        ip.push_back(str);\n        \n    Node *root = new Node(stoi(ip[0]));\n        \n    queue<Node*> queue;\n    queue.push(root);\n        \n    int i = 1;\n    while(!queue.empty() && i < ip.size()) {\n        Node* currNode = queue.front();\n        queue.pop();\n            \n        string currVal = ip[i];\n            \n        if(currVal != \"N\") {\n            currNode->left = new Node(stoi(currVal));\n                \n            queue.push(currNode->left);\n        }\n            \n        i++;\n        if(i >= ip.size())\n            break;\n        currVal = ip[i];\n            \n        if(currVal != \"N\") {\n            currNode->right = new Node(stoi(currVal));\n                \n            queue.push(currNode->right);\n        }\n        i++;\n    }\n    \n    return root;\n}\n\n\n\nclass Solution {\npublic:\n    int count(Node* root){\n        if(root==NULL){\n            return 0;\n        }\n        return 1+count(root->left)+count(root->right);\n    }\n    int hight(Node* root){\n        if(root==NULL){\n            return 0;\n        }\n        return 1+min(hight(root->left),hight(root->right));\n    }\n    int minDepth(Node* root) {\n        if(root==NULL){\n            return 0;\n        }\n        int c=count(root);\n            int h=hight(root);\n        if(h==1){\n            return c;\n        }\n        return h;\n    }\n};;\n\nint main()\n{\n    string treeString;\n\tgetline(cin,treeString);\n\tNode* root = buildTree(treeString);\n    Solution ob;\n\tcout<<ob.minDepth(root)<<endl;\n    return 0;\n} ",
    "rightcode": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node\n{\n    int data;\n    struct Node *left;\n    struct Node *right;\n\n    Node(int val) {\n        data = val;\n        left = right = NULL;\n    }\n}; \n\n\nNode* buildTree(string str)\n{   \n    if(str.length() == 0 || str[0] == 'N')\n        return NULL;\n    \n    vector<string> ip;\n    \n    istringstream iss(str);\n    \n    for(string str; iss >> str; )\n        ip.push_back(str);\n        \n    Node *root = new Node(stoi(ip[0]));\n        \n    queue<Node*> queue;\n    queue.push(root);\n        \n    int i = 1;\n    while(!queue.empty() && i < ip.size()) {\n        Node* currNode = queue.front();\n        queue.pop();\n            \n        string currVal = ip[i];\n            \n        if(currVal != \"N\") {\n            currNode->left = new Node(stoi(currVal));\n            \n            queue.push(currNode->left);\n        }\n            \n        i++;\n        if(i >= ip.size())\n            break;\n        currVal = ip[i];\n            \n        if(currVal != \"N\") {\n            currNode->right = new Node(stoi(currVal));\n                \n            queue.push(currNode->right);\n        }\n        i++;\n    }\n    \n    return root;\n}\n\n\nclass Solution {\npublic:\n    int minDepth(Node* root) {\n        if(root==NULL){\n            return 0;\n        }\n        if(root->left==NULL&&root->right==NULL){\n            return 1;\n        }\n        if(root->left==NULL){\n            return 1+minDepth(root->right);\n        }\n        if(root->right==NULL){\n            return 1+minDepth(root->left);\n        }\n        return 1+min(minDepth(root->left),minDepth(root->right));\n    }\n};;\n\n\nint main()\n{\n        string treeString;\n\t\tgetline(cin,treeString);\n\t\tNode* root = buildTree(treeString);\n        Solution ob;\n\t\tcout<<ob.minDepth(root)<<endl;\n    return 0;\n} "
  },
  {
    "questionid": "7",
    "difficulty": "Medium",
    "description":"<p>Given a string <code>s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is <strong>the smallest in lexicographical order</strong> among all possible results.</p><p>&nbsp;</p><strong><br /><hr>Input Guide :</strong><br> Insert you ans (which will be string ) without quotes <br>like <strong>acdfdd . <br></p><p><strong><br><hr>Example 1:</strong></p><strong>Input:</strong> s = \"bcabc\"<strong><br>Output:</strong> \"abc\"<p><strong><br><hr>Example 2:</strong></p><strong>Input:</strong> s = \"cbacdcbc\"<strong><br>Output:</strong> \"acdb\"<p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> consists of lowercase English letters.</li></ul>",    "wrongcodefile": "7wrongcode.cpp",
    "rightcodefile": "7rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nstring removeDuplicateLetters(string s) {\n        int n=s.size();\n        unordered_map<int,int>m;\n        for(int i=0;i<n;i++){\n            if(!m.count(s[i])){\n                m[s[i]]++;\n            }\n            else{\n                m[s[i]]=1;\n            }\n        }\n        stack<char>st;\n        bool arr[26]={0};\n        for(int i=0;i<n;i++){\n            if(st.empty()){\n                m[s[i]]--;\n                st.push(s[i]);\n                continue;\n            }\n            while(!st.empty()&&s[i]<=st.top()&&m[st.top()]!=0&&!arr[s[i]-'a']){\n                arr[st.top()-'a']=0;\n                st.pop(); \n            }\n            if(!arr[s[i]-'a']){\n                 st.push(s[i]);\n                 arr[s[i]-'a']=1;\n            }\n            m[s[i]]--;\n        }\n        string ans=\"\";\n        while(!st.empty()){\n            ans.push_back(st.top());\n            st.pop();\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n}\n\nint main(){\n    string s;\n    cin>>s;\n    string k=removeDuplicateLetters(s);\n    cout<<k;\n    \n}\n",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nstring removeDuplicateLetters(string s) {\n        int n=s.size();\n\n        unordered_map<int,int>m;\n        for(int i=0;i<n;i++){\n            if(!m.count(s[i])){\n                m[s[i]]++;\n            }\n            else{\n                m[s[i]]=1;\n            }\n        }\n        \n        stack<char>st;\n        bool arr[26]={0};\n        for(int i=0;i<n;i++){\n            if(st.empty()){\n                m[s[i]]--;\n                st.push(s[i]);\n                continue;\n            }\n            while(!st.empty()&&s[i]<=st.top()&&m[st.top()]!=0&&!arr[s[i]-'a']){\n                arr[st.top()-'a']=0;\n                \n                st.pop(); \n            }\n            if(!arr[s[i]-'a']){\n                 st.push(s[i]);\n                 arr[s[i]-'a']=1;\n            }\n            m[s[i]]--;\n        }\n        string ans=\"\";\n        while(!st.empty()){\n            ans.push_back(st.top());\n            st.pop();\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n}\n\nint main(){\n    string s;\n    cin>>s;\n    string k=removeDuplicateLetters(s);\n    cout<<k;\n    \n}\n"
  },
  {
    "questionid": "8",
    "difficulty": "Medium",
    "description":"<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if they are equal when both are typed into empty text editors</em>. <code>'#'</code> means a backspace character.</p><p>Note that after backspacing an empty text, the text will continue empty.</p><p>&nbsp;</p><strong><br /><hr>Input Guide :</strong><br> Insert you answer (which will be 2 string ) without quotes . <br> insert first string without qoutes then in diffrent line <br> insert the second string without qoutes.<br><strong><br> asdf#f <br> asd#df <br></br>NOTE : </strong> Do not forget to change the line for second string input.  <br></p><p><strong><br><hr>Example 1:</strong></p><strong><br>Input:</strong> s = \"ab#c\", t = \"ad#c\"<strong><br>Output:</strong> true<strong><br>Explanation:</strong> Both s and t become \"ac\".<p><strong><br><hr>Example 2:</strong></p><strong><br>Input:</strong> s = \"ab##\", t = \"c#d#\"<strong><br>Output:</strong> true<strong><br>Explanation:</strong> Both s and t become \"\".<p><strong><br><hr>Example 3:</strong></p><strong><br>Input:</strong> s = \"a#c\", t = \"b\"<strong><br>Output:</strong> false<strong><br><hr>Explanation:</strong> s becomes \"c\" while t becomes \"b\".<p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 30</span></code></li><li><code>s</code> and <code>t</code> only contain lowercase letters and <code>'#'</code> characters.</span></li></ul>",    "wrongcodefile": "8wrongcode.cpp",
    "rightcodefile": "8rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool backspaceCompare(string s, string t) {\n        stack<char>st;\n        int n=s.size();\n        for(int i=0;i<n;i++){\n            if(st.empty()){\n                st.push(s[i]);\n                continue;\n            }\n            if(s[i]=='#'){\n                st.pop();\n                continue;\n            }\n            st.push(s[i]);\n        }\n        string ans1=\"\";\n        while(!st.empty()){\n            ans1.push_back(st.top());\n            st.pop();\n        }\n        int m=t.size();\n        for(int i=0;i<m;i++){\n            if(st.empty()){\n                if(t[i]=='#'){\n                    continue;\n                }\n                st.push(t[i]);\n                continue;\n            }\n            if(t[i]=='#'){\n                st.pop();\n                continue;\n            }\n            st.push(t[i]);\n        }\n        string ans2=\"\";\n        while(!st.empty()){\n            ans2.push_back(st.top());\n            st.pop();\n        }\n        if(ans1==ans2){\n            return true;\n        }\n        return false;\n    }\n};\n\nint main(){\n    Solution ob;\n    string s;\n    string t;\n    cin>>s;\n    cin>>t;\n    cout<<ob.backspaceCompare(s,t);  \n}",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool backspaceCompare(string s, string t) {\n        stack<char>st;\n        int n=s.size();\n        for(int i=0;i<n;i++){\n            if(st.empty()){\n                if(s[i]=='#'){\n                    continue;\n                }\n                st.push(s[i]);\n                continue;\n            }\n            if(s[i]=='#'){\n                st.pop();\n                continue;\n            }\n            st.push(s[i]);\n        }\n        string ans1=\"\";\n        while(!st.empty()){\n            ans1.push_back(st.top());\n            st.pop();\n        }\n        int m=t.size();\n        for(int i=0;i<m;i++){\n            if(st.empty()){\n                if(t[i]=='#'){\n                    continue;\n                }\n                st.push(t[i]);\n                continue;\n            }\n            if(t[i]=='#'){\n                st.pop();\n                continue;\n            }\n            st.push(t[i]);\n        }\n        string ans2=\"\";\n        while(!st.empty()){\n            ans2.push_back(st.top());\n            st.pop();\n        }\n        if(ans1==ans2){\n            return true;\n        }\n        return false;\n    }\n};\n\nint main(){\n    Solution ob;\n    string s;\n    string t;\n    cin>>s;\n    cin>>t;\n    cout<<ob.backspaceCompare(s,t); \n    \n}"
  },
  {
    "questionid": "9",
    "difficulty": "Medium",
    "description":"<p>Given string num representing a non-negative integer <code>num</code>, and an integer <code>k</code>, return <em>the smallest possible integer after removing</em> <code>k</code> <em>digits from</em> <code>num</code>.</p><p>&nbsp;</p><strong><br /><hr>Input Guide :</strong><br> Insert Numeric string in the first line like <strong> 2345466 </strong> and in next line <br> insert non negative integer <strong>k</strong> <br><strong><br>NOTE : </strong> Do not forget to change the line <br></p><p><strong><br><hr>Example 1:</strong></p><strong><br>Input:</strong> num = \"1432219\", k = 3<strong><br>Output:</strong> \"1219\"<strong><br>Explanation:</strong> Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.<p><strong><br><hr>Example 2:</strong></p><strong><br>Input:</strong> num = \"10200\", k = 1<strong><br>Output:</strong> \"200\"<strong><br>Explanation:</strong> Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.<p><strong><br><hr>Example 3:</strong></p><strong><br>Input:</strong> num = \"10\", k = 2<strong><br>Output:</strong> \"0\"<strong><br>Explanation:</strong> Remove all the digits from the number and it is left with nothing which is 0.<p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= k &lt;= num.length &lt;= 100</code></li><li><code>num</code> consists of only digits.</li><li><code>num</code> does not have any leading zeros except for the zero itself.</li></ul>",   "wrongcodefile": "9wrongcode.cpp",
    "rightcodefile": "9rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    string removeKdigits(string num, int k){\n        int n=num.size();\n        stack<int>s;\n        if(num.size()==k){\n            return \"0\";\n        }\n        for(int i=0;i<n;i++){\n            if(s.empty()){\n                s.push(num[i]);\n                continue;\n            }\n            else{\n                if(s.top()>num[i]){\n                    while(!s.empty()&&s.top()>num[i]&&k!=0){\n                        s.pop();\n                        k--;\n                    }\n                }\n            }\n             s.push(num[i]);\n        }\n        string ans=\"\";\n        while(!s.empty()){\n            ans.push_back(s.top());\n            s.pop();\n        }\n        while(ans.size()!=0&&ans.back()=='0'){\n            ans.pop_back();\n        }\n        reverse(ans.begin(),ans.end());\n        \n        if(ans.size()==0||k>ans.size()){\n            return \"0\";\n        }\n        return ans;\n    }\n};\n\n\nint main(){\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    if(k>s.size()){\n        cout<<\"NOT Possible\";\n    }\n    Solution ob;\n    cout<<ob.removeKdigits(s,k);\n    return 0;\n}\n",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    string removeKdigits(string num, int k){\n        int n=num.size();\n        stack<int>s;\n        if(num.size()==k){\n            return \"0\";\n        }\n        for(int i=0;i<n;i++){\n            if(s.empty()){\n                s.push(num[i]);\n                continue;\n            }\n            else{\n                if(s.top()>num[i]){\n                    while(!s.empty()&&s.top()>num[i]&&k!=0){\n                        s.pop();\n                        k--;\n                    }\n                }\n            }\n             s.push(num[i]);\n        }\n        string ans=\"\";\n        while(!s.empty()){\n            ans.push_back(s.top());\n            s.pop();\n        }\n        while(ans.size()!=0&&ans.back()=='0'){\n            ans.pop_back();\n        }\n        reverse(ans.begin(),ans.end());\n        \n        if(ans.size()==0||k>ans.size()){\n            return \"0\";\n        }\n\n        for(int i=0;i<k;i++){\n            ans.pop_back();\n        }\n        return ans;\n    }\n};\n\nint main(){\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    if(k>s.size()){\n        cout<<\"NOT Possible\";\n    }\n    Solution ob;\n    cout<<ob.removeKdigits(s,k);\n    return 0;\n}\n"
  },
  {
    "questionid": "10",
    "difficulty": "Medium",
    "description":"<p>Given a alphanumeric string <code>s</code> of lower , upper case English letters ans numbers.</p><p>A good string is a string which doesn't have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li></ul><p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p><p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p><p><strong>Notice</strong> that an empty string is also good.</p><p>&nbsp;</p><p><strong><br /><hr>Input Guide :</strong><br> Insert you answer (which will be alphanumeric  string ) without quotes like <strong>1opPxX64Kk</strong> . <br></p></p><p><strong><br><hr>Example 1:</strong></p><strong><br>Input:</strong> s = \"leEeetcode\"<strong><br>Output:</strong> \"leetcode\"<strong><br>Explanation:</strong> In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\".<p><strong><br><hr>Example 2:</strong></p><strong><br>Input:</strong> s = \"1abBA6cC\"<strong><br>Output:</strong> \"16\"<strong><br>Explanation:</strong> We have many possible scenarios, and all <br>lead to the same answer. <br>For example:\"1abBA6cC\" --&gt; \"1aA6cC\" --&gt; \"16cC\" --&gt; \"16\" <br>\"1abBA6cC\" --&gt; \"1abBA6\" --&gt; \"1aA6\" --&gt; \"\"<p><strong><br><hr>Example 3:</strong></p><strong><br>Input:</strong> s = \"s\"<strong><br>Output:</strong> \"s\"<p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> contains only numbers  lower and upper case English letters.</li></ul>",    "wrongcodefile": "10wrongcode.cpp",
    "rightcodefile": "10rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    string makeGood(string s) {\n        stack<int>st;\n        int n=s.size();\n        for(int i=0;i<n;i++){\n            if(st.size()==0){\n                  st.push(s[i]);\n            }\n            else{\n                if(abs(s[i]-st.top())==32){\n                    st.top();\n                 }\n                 else{\n                     st.push(s[i]);\n                 }\n            }\n        }\n        string ans=\"\";\n        while(!st.empty()){\n            ans.push_back(char(st.top()));\n            st.pop();\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\nint main(){\n    string s;\n    cin>>s;\n    Solution ob;\n    cout<<ob.makeGood(s);\n    return 0;\n}",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    string makeGood(string s) {\n        stack<int>st;\n        int n=s.size();\n        for(int i=0;i<n;i++){\n            if(st.size()==0){\n                  st.push(s[i]);\n            }\n            else{\n                if(abs(s[i]-st.top())==32){\n                    if(s[i]>='A'&&s[i]<='Z'||char(st.top())>='A'&&char(st.top())<='z'){\n                         st.pop();\n                    }\n                 }\n                 else{\n                     st.push(s[i]);\n                 }\n            }\n        }\n        string ans=\"\";\n        while(!st.empty()){\n            ans.push_back(char(st.top()));\n            st.pop();\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\nint main(){\n    string s;\n    cin>>s;\n    Solution ob;\n    cout<<ob.makeGood(s);\n    return 0;\n}\n\n\n"
  },
  {
    "questionid": "11",
    "difficulty": "Medium",
    "description":"<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>&nbsp;</p><p><strong>&nbsp;</strong></p><p><strong><br /><hr>Input Guide :</strong><br> Insert both the list (which will be added for result ) in the first line enter length of list1 in the second line enter the list 1 values separated by white spaces like 1 2 3 4. in the next line enter the length of list 2 in the next line insert list 2 values separated by white spaces <br> example <strong> <br>3 <br> 1 2 3 <br> 3 <br> 2 3 4 <br></strong>  <br></p></p><hr /><p><strong>Example 1:</strong></p><strong><br />Input:</strong> n = 4 <br>l1 = [7,2,4,3], <br>  m = 3 <br> l2 = [5,6,4]<strong><br />Output:</strong> [7,8,0,7]<p><strong>&nbsp;</strong></p><hr /><p><strong>Example 2:</strong></p><strong><br />Input:</strong> n = 3 <br> l1 = [2,4,3], m = 3 <br> l2 = [5,6,4]<strong><br />Output:</strong> [8,0,7]<p><strong>&nbsp;</strong></p><hr /><p><strong>&nbsp;</strong></p><p><strong>Example 3:</strong></p><strong><br />Input:</strong> n = 1 <br> l1 = [0],<br> m = 1<br> l2 = [0]<strong><br />Output:</strong> [0]<p>&nbsp;</p><p><strong>&nbsp;</strong></p><p><strong>&nbsp;</strong></p><p><strong><hr>Constraints:</strong></p><ul><li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>It is guaranteed that the list represents a number that does not have leading zeros.</li></ul>",    "wrongcodefile": "11wrongcode.cpp",
    "rightcodefile": "11rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\n\nstruct Node {\n    int val;\n    struct Node* next;\n    Node(int x) {\n        val = x;\n        next = NULL;\n    }\n};\n\nstruct Node* buildList(int size)\n{\n    int val;\n    cin>> val;\n    \n    Node* head = new Node(val);\n    Node* tail = head;\n    \n    for(int i=0; i<size-1; i++)\n    {\n        cin>> val;\n        tail->next = new Node(val);\n        tail = tail->next;\n    }\n    \n    return head;\n}\n\nvoid printList(Node* n)\n{\n    while(n)\n    {\n        cout<< n->val << \" \";\n        n = n->next;\n    }\n    cout<< endl;\n}\n\n\nclass Solution\n{\n    public:\n    struct Node* addTwoLists(struct Node* l1, struct Node* l2)\n    {\n        stack<int>s1;\n        stack<int>s2;\n        struct Node* h1=l1;\n        struct Node* h2=l2;\n        while(h1){\n            s1.push(l1->val);\n            h1=h1->next;\n            l1=l1->next;\n        }\n         while(h2){\n            s2.push(l2->val);\n            h2=h2->next;\n            l2=l2->next;\n        }\n        int rem=0;\n        stack<int>s;\n        while(!s1.empty()&&!s2.empty()){\n            int k=s1.top()+s2.top()+rem;\n            if(k>9){\n                s.push(k%10);\n                rem=1;\n            }\n            else{\n                s.push(k);\n                rem=0;\n            }\n            s1.pop();\n            s2.pop();\n        }\n        while(!s1.empty()){\n            int k=(rem+s1.top());\n            if(k>9){\n                 s.push(k%10);\n                rem=1;\n            }\n            else{\n                 s.push(k);\n                rem=0;\n            }\n                   s1.pop();\n        }\n        while(!s2.empty()){\n            int k=(rem+s2.top());\n            if(k>9){\n                 s.push(k%10);\n                rem=1;\n            }\n            else{\n                 s.push(k);\n                rem=0;\n            }\n            s2.pop();\n        }\n        struct Node* head=NULL;\n        struct Node* tail=NULL;\n        while(!s.empty()){\n            struct Node* temp=new Node(s.top());\n            if(head==NULL){\n                head=temp;\n                tail=temp; \n            }\n            else{\n                tail->next=temp;\n                tail=tail->next;\n            }\n            s.pop();\n        }\n        return head;\n    }\n};\n\n\nint main()\n{\n    int n, m;\n    \n    cin>>n;\n    Node* first = buildList(n);\n    \n    cin>>m;\n    Node* second = buildList(m);\n    Solution ob;\n    Node* res = ob.addTwoLists(first,second);\n    printList(res);\n    \n    return 0;\n}\n\n",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nstruct Node {\n    int val;\n    struct Node* next;\n    Node(int x) {\n        val = x;\n        next = NULL;\n    }\n};\n\nstruct Node* buildList(int size)\n{\n    int val;\n    cin>> val;\n    \n    Node* head = new Node(val);\n    Node* tail = head;\n    \n    for(int i=0; i<size-1; i++)\n    {\n        cin>> val;\n        tail->next = new Node(val);\n        tail = tail->next;\n    }\n    \n    return head;\n}\n\nvoid printList(Node* n)\n{\n    while(n)\n    {\n        cout<< n->val << \" \";\n        n = n->next;\n    }\n    cout<< endl;\n}\n\n\nclass Solution\n{\n    public:\n    struct Node* addTwoLists(struct Node* l1, struct Node* l2)\n    {\n        stack<int>s1;\n        stack<int>s2;\n        struct Node* h1=l1;\n        struct Node* h2=l2;\n        while(h1){\n            s1.push(l1->val);\n            h1=h1->next;\n            l1=l1->next;\n        }\n         while(h2){\n            s2.push(l2->val);\n            h2=h2->next;\n            l2=l2->next;\n        }\n        int rem=0;\n        stack<int>s;\n        while(!s1.empty()&&!s2.empty()){\n            int k=s1.top()+s2.top()+rem;\n            if(k>9){\n                s.push(k%10);\n                rem=1;\n            }\n            else{\n                s.push(k);\n                rem=0;\n            }\n            s1.pop();\n            s2.pop();\n        }\n        while(!s1.empty()){\n            int k=(rem+s1.top());\n            if(k>9){\n                 s.push(k%10);\n                rem=1;\n            }\n            else{\n                 s.push(k);\n                rem=0;\n            }\n                   s1.pop();\n        }\n        while(!s2.empty()){\n            int k=(rem+s2.top());\n            if(k>9){\n                 s.push(k%10);\n                rem=1;\n            }\n            else{\n                 s.push(k);\n                rem=0;\n            }\n            s2.pop();\n        }\n        if(rem>0){\n            s.push(rem);\n        }\n        struct Node* head=NULL;\n        struct Node* tail=NULL;\n        while(!s.empty()){\n            struct Node* temp=new Node(s.top());\n            if(head==NULL){\n                head=temp;\n                tail=temp; \n            }\n            else{\n                tail->next=temp;\n                tail=tail->next;\n            }\n            s.pop();\n        }\n        return head;\n    }\n};\n\n\n\nint main()\n{\n    int n, m;\n    \n    cin>>n;\n    Node* first = buildList(n);\n    \n    cin>>m;\n    Node* second = buildList(m);\n    Solution ob;\n    Node* res = ob.addTwoLists(first,second);\n    printList(res);\n    \n    return 0;\n}\n"
  },
  {
    "questionid": "12",
    "difficulty": "Medium",
    "description":"<p>Given a string <code>s</code> containing only three types of characters: <code>'('</code>, <code>')'</code> and <code>'*'</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is <strong>valid</strong></em>.</p><p>The following rules define a <strong>valid</strong> string:</p><ul><li>Any left parenthesis <code>'('</code> must have a corresponding right parenthesis <code>')'</code>.</li><li>Any right parenthesis <code>')'</code> must have a corresponding left parenthesis <code>'('</code>.</li><li>Left parenthesis <code>'('</code> must go before the corresponding right parenthesis <code>')'</code>.</li><li><code>'*'</code> could be treated as a single right parenthesis <code>')'</code> or a single left parenthesis <code>'('</code> or an empty string <code>\"\"</code>.</li></ul><p>&nbsp;</p><p><strong><br /><hr>Input Guide :</strong><br> Insert you ans (which will be string ) without quotes like ()(* . <br></p><p><strong><br /><hr>Example 1:</strong></p><strong><br />Input:</strong> s = \"()\"<strong><br />Output:</strong> true<p><strong>&nbsp;</strong></p><hr /><p><strong>Example 2:</strong></p><strong><br />Input:</strong> s = \"(*)\"<strong><br />Output:</strong> true<p><strong>&nbsp;</strong></p><hr /><p><strong>Example 3:</strong></p><strong><br />Input:</strong> s = \"(*))\"<strong><br />Output:</strong> true<p>&nbsp;</p><p><strong>&nbsp;</strong></p><hr /><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code> is <code>'('</code>, <code>')'</code> or <code>'*'</code>.</li></ul>",    "wrongcodefile": "12wrongcode.cpp",
    "rightcodefile": "12rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool checkValidString(string s) {\n        stack<int>open;\n        stack<int>star;\n        int n=s.size();\n        for(int i=0;i<n;i++){\n            if(s[i]=='('){\n                open.push(i);\n            }\n            else if(s[i]=='*'){\n                star.push(i);\n            }\n            else{\n                if(!open.empty()){\n                    open.pop();\n                }\n                else if(!star.empty()){\n                    star.pop();\n                }\n                else{\n                    return false;\n                }\n            }\n        }\n        while(!open.empty()){\n            if(star.empty()){\n                return false;\n            }\n            open.pop();\n            star.pop();\n        }\n        return true;\n    }\n};\n\nint main(){\n    string s;\n    cin>>s;\n    Solution ob;\n    cout<<ob.checkValidString(s);\n    return 0;\n}\n\n\n",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool checkValidString(string s) {\n        stack<int>open;\n        stack<int>star;\n        int n=s.size();\n        for(int i=0;i<n;i++){\n            if(s[i]=='('){\n                open.push(i);\n            }\n            else if(s[i]=='*'){\n                star.push(i);\n            }\n            else{\n                if(!open.empty()){\n                    open.pop();\n                }\n                else if(!star.empty()){\n                    star.pop();\n                }\n                else{\n                    return false;\n                }\n            }\n        }\n        while(!open.empty()){\n            if(star.empty()){\n                return false;\n            }\n            else if(open.top()<star.top()){\n                open.pop();\n                star.pop();\n            }\n            else{\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};\n\nint main(){\n    string s;\n    cin>>s;\n    Solution ob;\n    cout<<ob.checkValidString(s);\n    return 0;\n}\n\n\n"
  },
  {
    "questionid": "13",
    "difficulty": "Hard",
    "description":"<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p>&nbsp;</p><strong><br /><hr>Input Guide :</strong><br> Insert you answer as a string and dictionary of string  <br> in the first line insert string and in next line insert length of dictionary (no of string in dictionary) then in the next line insert string in the dictionary in space separated manner like :<br> <strong> <br>applepine &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(main string)<br> 4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(size of string dictionary)<br> pine apple pen we &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(space separated strings for dictionary)</strong>. <br></p><p><strong><br><hr>Example 1:</strong></p><strong><br>Input:</strong> s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]<strong><br>Output:</strong> [\"cats and dog\",\"cat sand dog\"]<p><strong><br><hr>Example 2:</strong></p><strong><br>Input:</strong> s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]<strong><br>Output:</strong> [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]<strong><br>Explanation:</strong> Note that you are allowed to reuse a dictionary word.<p><strong><br><hr>Example 3:</strong></p><strong><br>Input:</strong> s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]<strong><br>Output:</strong> []<p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li><li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li><li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li></ul>",    "wrongcodefile": "13wrongcode.cpp",
    "rightcodefile": "13rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<map>\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<string ,bool>map;\n    bool valid(string s){\n        if(map[s]){\n            return true;\n        }\n        return false;\n    }\n    vector<string>ans;\n    void helper(string&s,int i,string temp){\n        if(i==s.size()){\n            ans.push_back(temp);\n            return ;\n        }\n        for(int j=i;j<s.size();j++){\n            if(valid(s.substr(i,j-i+1))){\n                if(i!=0){\n                    temp+=\" \";\n                }\n\n                helper(s,j+1,temp+s.substr(i,j-i+1));\n            }\n        }\n        return ;\n    }\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n  \n        for(int i=0;i<wordDict.size();i++){\n            map[wordDict[i]]=true;\n        }\n        helper(s,0,\"\");\n        return ans;\n    }\n};\n\nint main(){\n    string s;\n    cin>>s;\n    vector<string>dic;\n    int l;\n    cin>>l;\n    for(int i=0;i<l;i++){\n        string st;\n        cin>>st;\n        dic.push_back(st);\n    }\n    Solution ob;\n    vector<string> ans=ob.wordBreak(s,dic);\n    for(int i=0;i<ans.size();i++){\n        cout<<ans[i]<<\" \";\n    }\n    return 0;\n}",
    "rightcode": "#include<iostream>\n#include<map>\n#include<bits/stdc++.h>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<string ,bool>map;\n    bool valid(string s){\n        if(map[s]){\n            return true;\n        }\n        return false;\n    }\n    vector<string>ans;\n    void helper(string&s,int i,string temp){\n        if(i==s.size()){\n            ans.push_back(temp);\n            return ;\n        }\n        for(int j=i;j<s.size();j++){\n            if(valid(s.substr(i,j-i+1))){\n                if(temp.size()!=0){\n                    if(temp[temp.size()-1]!=' '){\n                         temp+=\" \";\n                    }\n                }\n                \n                helper(s,j+1,temp+s.substr(i,j-i+1));\n            }\n        }\n        return ;\n    }\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n  \n        for(int i=0;i<wordDict.size();i++){\n            map[wordDict[i]]=true;\n        }\n        helper(s,0,\"\");\n        return ans;\n    }\n};\n\nint main(){\n    string s;\n    cin>>s;\n    vector<string>dic;\n    int l;\n    cin>>l;\n    for(int i=0;i<l;i++){\n        string st;\n        cin>>st;\n        dic.push_back(st);\n    }\n    Solution ob;\n    vector<string> ans=ob.wordBreak(s,dic);\n    for(int i=0;i<ans.size();i++){\n        cout<<ans[i]<<\" \";\n    }\n    return 0;\n}"
},
  {
    "questionid": "14",
    "difficulty": "Medium",
    "description":"<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p>&nbsp;</p><p><strong>&nbsp;</strong></p><hr /><p><strong><br />Input Guide :</strong>Insert you answer(which will be array) in the first line insert size of array and in second line insert array in a line as space separated values  like :  <strong> <br>8 <br>1 3 4 0 8 9 7 6 4</striong>. <br></p></p><p><strong><br><hr>Example 1:</strong></p><strong><br />Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]<strong><br />Output:</strong> 6<strong><br />Explanation:</strong>array [0,1,0,2,1,0,1,3,2,1,2,1]. <br>In this case, 6 units of rain water are being trapped.<p><strong>&nbsp;</strong></p><hr /><p><strong>Example 2:</strong></p><strong><br />Input:</strong> height = [4,2,0,3,2,5]<strong><br />Output:</strong> 9<p>&nbsp;</p><p><strong>&nbsp;</strong></p><hr /><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li><li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li></ul>",    "wrongcodefile": "14wrongcode.cpp",
    "rightcodefile": "14rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<stack>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int trap(vector<int>& h) {\n        stack<int>s;\n        int n=h.size();\n        vector<int>t(h.size(),-1);\n        for(int i=0;i<n;i++){\n            if(s.empty()){\n                s.push(i);\n            }\n            else{\n                if(h[i]>=h[s.top()]){\n                    while((!s.empty())&&h[i]>=h[s.top()]){\n                        t[s.top()]=i;\n                        s.pop();\n                    }\n                }\n                s.push(i);\n            }\n        }\n        while(!s.empty()){\n            t[s.top()]=-1;\n            s.pop();\n        }\n        int maxm=-1;\n        int curr=0;\n        for(int i=0;i<n;i++){\n            int j=i+1;\n            for(;j<t[i];j++){\n                curr+=abs(h[i]-h[j]);\n            }\n            i=j-1;\n        }\n        return curr;\n    }\n};\n\nint main(){\n    Solution ob;\n    int n;\n    cin>>n;\n    vector<int>v;\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        v.push_back(k);\n    }\n    cout<<ob.trap(v);\n}",
    "rightcode": "#include<iostream>\n#include<stack>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int trap(vector<int>& h) {\n        int n=h.size();\n        vector<int>maxl(n);\n        vector<int>maxr(n);\n        int m=h[0];\n        for(int i=0;i<n;i++){\n            m=max(m,h[i]);\n            maxl[i]=m;\n        }\n        m=h[n-1];\n        cout<<endl;\n        for(int i=n-1;i>=0;i--){\n            m=max(m,h[i]);\n            maxr[i]=m;\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            ans+=min(maxl[i],maxr[i])-h[i];\n        }\n        return ans;\n    }\n};\n\nint main(){\n    Solution ob;\n    int n;\n    cin>>n;\n    vector<int>v;\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        v.push_back(k);\n    }\n    cout<<ob.trap(v);\n}\n"
  },
  {
    "questionid": "15",
    "difficulty": "Medium",
    "description":"<p>Given the array <code>prices</code> where <code>prices[i]</code> is the price of the <code>ith</code> item in a shop. There is a special discount for items in the shop, if you buy the <code>ith</code> item, then you will receive a discount equivalent to <code>prices[j]</code> where <code>j</code> is the <strong>minimum</strong>&nbsp;index such that <code>j &gt; i</code> and <code>prices[j] &lt;= prices[i]</code>, otherwise, you will not receive any discount at all.</p><p><em>Return an array where the <code>ith</code> element is the final price you will pay for the <code>ith</code> item of the shop considering the special discount.</em></p><p>&nbsp;</p><strong><br /><hr>Input Guide :</strong><br> Insert you answer (which will be array )in the first line we have to insert length of array and in next line insert array as space separatwed values  like <strong><br > 4 <br> 1 6 8 4 .</strong> <br></p><p><strong><br><hr>Example 1:</strong></p><strong><br>Input:</strong> prices = [8,4,6,2,3]<strong><br>Output:</strong> [4,2,4,2,3]<strong><br>Explanation:</strong>&nbsp;For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.&nbsp;For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.&nbsp;For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.&nbsp;For items 3 and 4 you will not receive any discount at all.<p><strong><br><hr>Example 2:</strong></p><strong><br>Input:</strong> prices = [1,2,3,4,5]<strong><br>Output:</strong> [1,2,3,4,5]<strong><br>Explanation:</strong> In this case, for all items, you will not receive any discount at all.<p><strong><br><hr>Example 3:</strong></p><strong><br>Input:</strong> prices = [10,1,1,6]<strong><br>Output:</strong> [9,0,1,6]<p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 500</code></li><li><code>1 &lt;= prices[i] &lt;= 10^3</code></li></ul>",    "wrongcodefile": "15wrongcode.cpp",
    "rightcodefile": "15rightcode.cpp",
    "wrongcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& p) {\n        int n=p.size();\n        stack<int> s;\n        vector<int>d (n,-1);\n        for(int i=0;i<p.size();i++){\n            if(s.size()==0){\n                s.push(i);\n            }\n            else{\n                if(p[s.top()]>p[i]){\n                    while(!s.empty()&&p[s.top()]>=p[i]){\n                         d[s.top()]=i;\n                        s.pop();\n                    }\n                }\n                s.push(i);\n            }\n        }\n        vector<int>v;\n        for(int i=0;i<n;i++){\n            if(d[i]!=-1){\n                v.push_back(p[i]-p[d[i]]);\n            }\n            else{\n                v.push_back(p[i]);\n            }\n        }\n        return v;\n    }\n};\n\nint main(){\n    vector<int>v;\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        int t;\n        cin>>t;\n        v.push_back(t);\n    }\n    Solution ob;\n    vector<int>ans=ob.finalPrices(v);\n    for(int i=0;i < ans.size();i++){\n        cout<<ans[i]<<\" \";\n    }\n    return 0;\n}",
    "rightcode": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n// #include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& p) {\n        int n=p.size();\n        stack<int> s;\n        vector<int>d (n,-1);\n        for(int i=0;i<p.size();i++){\n            if(s.size()==0){\n                s.push(i);\n            }\n            else{ \n                if(p[s.top()]>=p[i]){\n                    while(!s.empty()&&p[s.top()]>=p[i]){\n                         d[s.top()]=i;\n                        s.pop();\n                    }\n                }\n                s.push(i);\n            }\n        }\n        vector<int>v;\n        for(int i=0;i<n;i++){\n            if(d[i]!=-1){\n                v.push_back(p[i]-p[d[i]]);\n            }\n            else{\n                v.push_back(p[i]);\n            }\n        }\n        return v;\n    }\n};\n\n\nint main(){\n    vector<int>v;\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        int t;\n        cin>>t;\n        v.push_back(t);\n    }\n    Solution ob;\n    vector<int>ans=ob.finalPrices(v);\n    for(int i=0;i < ans.size();i++){\n        cout<<ans[i]<<\" \";\n    }\n    return 0;\n}"
  }
]
