[
    {
        "questionid" : "1",
        "difficulty":"1Easy",
        "description":"<p>&nbsp;Given an expression string <strong>x</strong>. Examine whether the pairs and the orders of &ldquo;{&ldquo;,&rdquo;}&rdquo;,&rdquo;(&ldquo;,&rdquo;)&rdquo;,&rdquo;[&ldquo;,&rdquo;]&rdquo; are correct in exp.<br />For example, the function should return 'true' for exp = &ldquo;[()]{}{[()()]()}&rdquo; and 'false' for exp = &ldquo;[(])&rdquo;.<br></br><hr><p><strong>Example 1:</strong></p><strong>Input</strong>   :  {([])}<br><strong>Output </strong> :  true<br><strong>Explanation</strong> : { ( [ ] ) }.&nbsp;Same kind of brackets can form balaced pairs, with <br>0 number of unbalanced bracket.<p></p></p><p><br><hr><strong>Exapmle 2 :</strong><br><strong>Input</strong> : ()<br><strong>Output </strong> : true<br><strong>Explanation </strong> : (). Same bracket can form balanced pairs,and here <br>only 1 type of bracket is present and in<br>balanced way<p></p><br><hr><p><strong>Example 3:</strong></p><strong>Input </strong> : ([]<br><strong>Output  </strong> : false<br><strong>Explanation </strong> : ([]. Here square bracket is balanced but the<br> small bracket is not balanced and <br>Hence , the output will be unbalanced.<p></p><br><hr><strong>Constraints:</strong><br />1 &le; |x| &le; 32000<p></p></p>",
        "wrongcode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\n// } Driver Code Ends\n\nclass Solution\n{\npublic:\n    // Function to check if brackets are balanced or not.\n    bool ispar(string x)\n    {\n        stack<int> s;\n        // closing bracket ke liye 1 openning ke liye 0;\n        int i = 0;\n        while (i < x.size())\n        {\n            if (x[i] == '(' || x[i] == '{' || x[i] == '[')\n            {\n                if (x[i] == '(')\n                {\n                    s.push(-1);\n                }\n                if (x[i] == '[')\n                {\n                    s.push(0);\n                }\n                if (x[i] == '{')\n                {\n                    s.push(1);\n                }\n            }\n            else\n            {\n                if (s.size() == 0)\n                {\n                    return false;\n                }\n                else\n                {\n                    if (x[i] == ')' && s.top() != -1)\n                    {\n                        return false;\n                    }\n                    if (x[i] == ']' && s.top() != 0)\n                    {\n                        return false;\n                    }\n                    if (x[i] == '}' && s.top() != 1)\n                    {\n                        return false;\n                    }\n                    s.pop();\n                }\n            }\n            i++;\n        }\n\n        return true;\n    }\n};\n\n// { Driver Code Starts.\n\nint main()\n{\n    string a;\n    cin >> a;\n    Solution obj;\n    if (obj.ispar(a))\n        cout << \"balanced\" << endl;\n    else\n        cout << \"not balanced\" << endl;\n} // } Driver Code Ends",
        "wrongcodefile" : "1wrongcode.cpp",
        "rightcodefile" : "1rightcode.cpp"
    },
    {
        "questionid" : "2",
        "difficulty":"2Hard",
        "description":"Given a string <strong>S</strong> consisting of only opening and closing curly brackets<strong> '{'</strong> and<strong> '}',</strong>&nbsp;find out the minimum&nbsp;number of reversals required to convert the string into a balanced expression.<br />A reversal means changing <strong>'{'</strong> to <strong>'}'</strong> or vice-versa.<p></p><br><hr><p>Example 1&nbsp;:</strong><strong><br>Input&nbsp;:&nbsp;</strong>S = <strong>{&nbsp;{&nbsp;{&nbsp;}&nbsp;}&nbsp;{&nbsp;{&nbsp;{</strong><strong><br>Output&nbsp;:&nbsp;</strong>&nbsp; 2<strong><br>Explanation</strong>&nbsp;:&nbsp;<br> One way to balance is:<strong>{&nbsp;</strong>{&nbsp;{&nbsp;}&nbsp;}&nbsp;<strong>{&nbsp;}&nbsp;}</strong>. There is no balanced sequence that can be formed in lesser reversals.<br><hr><strong>Exapmle&nbsp; :&nbsp;2 <br>Input</strong>&nbsp;:&nbsp;S = {&nbsp;{&nbsp;}&nbsp;{&nbsp;{&nbsp;{&nbsp;}&nbsp;{&nbsp;{&nbsp;}&nbsp;}&nbsp;{&nbsp;{&nbsp;<strong><br>Output:</strong> -1<strong><br>Explanation</strong>: There's no way we can balancethis sequence of braces.<br><hr><p><strong>Expected Time Complexity:&nbsp;</strong>O(|S|).<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</p><p><strong>Constraints:</strong><br />1 &le; |S| &le; 10<sup>5</sup></p>",
        "wrongcode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\nint countRev(string s);\nint main()\n{\n    string s;\n    cin >> s;\n    cout << countRev(s) << '\\n';\n}\nint countRev(string s)\n{\n    stack<char> st;\n    if (s.size() % 2 != 0)\n    {\n        return -1;\n    }\n    for (int i = 0; i < s.size(); i++)\n    {\n        if (st.empty())\n        {\n            st.push(s[i]);\n        }\n        else\n        {\n            if (st.top() == '{' && s[i] == '}')\n            {\n                st.pop();\n            }\n            else\n            {\n                st.push(s[i]);\n            }\n        }\n    }\n    // cout<<st.size();\n    // int count=0;\n    // while(!st.empty()){\n    //     char top=st.top();\n    //     st.pop();\n    //     if(st.top()==top){\n    //         count=count+1;\n    //     }\n    //     else{\n    //        count= count+2;\n    //     }\n    //     st.pop();\n    // }\n    return st.size() / 2;\n}",
        "wrongcodefile" : "2wrongcode.cpp",
        "rightcodefile" : "2rightcode.cpp"
    },
    {
        "questionid" : "3",
        "difficulty":"3Hard",
        "description":"<p>Given a string<strong> S </strong>delete the characters which are appearing more than once consecutively.</p><br><hr><br><p><strong>Example 1:</strong></p><strong>Input:</strong>S = aabb<strong><br>Output:  </strong>ab <strong><br>Explanation:<br></strong> 'a' at 2nd position isappearing 2nd time consecutively.Similiar explanation for b at 4th position.<br><br><hr><br><p><strong>Example 2:</strong><strong><br>Input</strong> : S = aabaa<strong><br>Output:</strong>  aba <strong><br>Explanation:</strong> 'a' at 2nd position is appearing 2nd time consecutively.'a' at fifth position is appearing 2nd time consecutively.</p><p><strong><br><hr><br>GUID:</strong><br />Code starts from&nbsp; the function <strong>removeConsecutiveCharacter()</strong> which accepts a string as input parameter and <strong>returns</strong> modified string. try and find out a (there could be many) invalid test case which will not work out with this solution for current question&nbsp;</p><p><strong><br><hr>Constraints:</strong><br />1&lt;=|S|&lt;=10<sup>5</sup><br />All characters are lowercase alphabets.</p>",
        "wrongcode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\n// } Driver Code Ends\n\nclass Solution\n{\npublic:\n    void helper(string &S, int index, string &ans)\n    {\n        if (index == S.size() - 1)\n        {\n            if (S[index] == S[index - 1])\n            {\n                ans.push_back(S[index]);\n            }\n            return;\n        }\n        if (index == S.size() - 1)\n        {\n            ans.push_back(S[index]);\n            return;\n        }\n        if (S[index] == S[index + 1])\n        {\n            helper(S, index + 1, ans);\n        }\n        else\n        {\n            ans.push_back(S[index]);\n            helper(S, index + 1, ans);\n            return;\n        }\n    }\n    string removeConsecutiveCharacter(string S)\n    {\n        string ans;\n        helper(S, 0, ans);\n        return ans;\n    }\n};\n\n// { Driver Code Starts.\nint main()\n{\n    string s;\n    cin >> s;\n    Solution ob;\n    cout << ob.removeConsecutiveCharacter(s) << endl;\n}",
        "wrongcodefile" : "3wrongcode.cpp",
        "rightcodefile" : "3rightcode.cpp"
    },
    {
        "questionid" : "4",
        "difficulty":"4Hard",
        "description":"<p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p><ul><li>For example, <code>&quot0.1.2.201&quot</code> and <code>&quot192.168.1.1&quot</code> are <strong>valid</strong> IP addresses, but <code>&quot0.011.255.245&quot</code>, <code>&quot192.168.1.312&quot</code> and <code>&quot192.168@1.1&quot</code> are <strong>invalid</strong> IP addresses.</li></ul><p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into </em><code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p><br><hr><p><strong>Example 1:</strong></p><p><strong>Input:</strong> s = &quot25525511135&quot</p><strong>Output:</strong> [&quot255.255.11.135&quot,&quot255.255.111.35&quot]<p><strong><br><hr>Example 2:</strong></p><p><strong>Input:</strong> s = &quot1111&quot</p><p><strong>Output:</strong> [&quot1.1.1.1&quot]</p><br><hr><p><strong>Example 3:</strong></p><p><strong>Input:</strong> s = &quot144&quot</p><p><strong>Output:</strong> [&quot&quot]</p><p><strong>Explanation: size of string is less than 4 so it could not be converted into a valid IP .</strong></p><p><strong></strong></p><p><strong><br><hr>Example 4:</strong></p><p><strong>Input:</strong> s = &quot74574377238232&quot</p><p><strong>Output:</strong> [&quot&quot]</p><p><strong>Explanation: size of string is less greater than 12 so it could not be converted into a valid IP .</strong></p><p><strong></strong></p>",
        "wrongcode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\nclass Solution\n{\npublic:\n    vector<string> ans;\n    bool valid(string s)\n    {\n        if (s[0] == '0')\n        {\n            return false;\n        }\n        int v = stoi(s);\n        if (v > 255)\n        {\n            return false;\n        }\n        return true;\n    }\n    void helper(string &s, int i, int part, string res)\n    {\n        if (s.size() == i || part == 4)\n        {\n            if (s.size() == i && part == 4)\n            {\n                ans.push_back(res.substr(0, res.size() - 1));\n                return;\n            }\n            return;\n        }\n        if (s.size() - i >= 1 && valid(s.substr(i, 1)))\n        {\n            helper(s, i + 1, part + 1, res + s[i] + \".\");\n        }\n        if (s.size() - i >= 2 && valid(s.substr(i, 2)))\n        {\n            helper(s, i + 2, part + 1, res + s.substr(i, 2) + \".\");\n        }\n        if (s.size() - i >= 3 && valid(s.substr(i, 3)))\n        {\n            helper(s, i + 3, part + 1, res + s.substr(i, 3) + \".\");\n        }\n        return;\n    }\n    vector<string> restoreIpAddresses(string s)\n    {\n        helper(s, 0, 0, \"\");\n        return ans;\n    }\n};\nint main()\n{\n    string s;\n    cin >> s;\n    vector<string> v;\n    Solution ob;\n    v = ob.restoreIpAddresses(s);\n    int n = v.size();\n    for (int i = 0; i < n; i++)\n    {\n        cout << v[i];\n    }\n    cout << endl;\n    return 0;\n}",
        "wrongcodefile" : "4wrongcode.cpp",
        "rightcodefile" : "4rightcode.cpp"
    },
    {
        "questionid" : "5",
        "difficulty":"5Hard",
        "description":"<p>&nbsp;</p><p>A parentheses string is a <strong>non-empty</strong> string consisting only of '(' and ')'. It is valid if <strong>any</strong> of the following conditions is <strong>true</strong>:</p><ul><li>It is ().</li><li>It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.</li><li>It can be written as (A), where A is a valid parentheses string.</li></ul><p>You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For <strong>each</strong> index i of locked,</p><ul><li>If locked[i] is '1', you <strong>cannot</strong> change s[i].</li><li>But if locked[i] is '0', you <strong>can</strong> change s[i] to either '(' or ')'.</li></ul><p>Return true <em>if you can make s a valid parentheses string</em>. Otherwise, return false.</p><br><hr><br><strong>Example 1:</strong><strong><br>Input:</strong> s = &quot;))()))&quot;, locked = &quot;010100&quot;<strong><br>Output:</strong> true<strong><br>Explanation:</strong> locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.<br><br><hr><br><p><strong>Example 2:</strong> <strong><br>Input:</strong> s = &quot;()()&quot;, locked = &quot;0000&quot; <strong><br>Output:</strong> true <strong><br>Explanation:</strong> We do not need to make any changes because s is already valid.</p><br><hr><strong>Example 3:</strong><strong><br>Input:</strong> s = &quot;)&quot;, locked = &quot;0&quot;<strong><br>Output:</strong> false<strong><br>Explanation:</strong> locked permits us to change s[0]. Changing s[0] to either '(' or ')' will not make s valid.<br><br><hr><br><p><strong>Constraints:</strong></p><ul><li><code>n == s.length == locked.length</code></li><li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code>s[i]</code> is either <code>'('</code> or <code>')'</code>.</li><li><code>locked[i]</code> is either '0' or 1'.</li></ul>",
        "wrongcode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nclass Solution\n{\npublic:\n    bool canBeValid(string s, string l)\n    {\n        stack<int> st;\n        int n = s.size();\n        if (n % 2 != 0)\n        {\n            return false;\n        }\n        for (int i = 0; i < n; i++)\n        {\n            if (s[i] == ')' && !st.empty() && s[st.top()] == '(')\n            {\n                st.pop();\n                continue;\n            }\n            else\n            {\n                st.push(i);\n            }\n        }\n        if (st.size() % 2 != 0)\n        {\n            return false;\n        }\n        while (!st.empty())\n        {\n            char a = s[st.top()];\n            int i = st.top();\n            st.pop();\n            char b = s[st.top()];\n            int j = st.top();\n            if (a == b)\n            {\n                if (a == '(')\n                {\n                    if (l[i] != '0' || l[j] != '0')\n                    {\n                        return false;\n                    }\n                }\n                else\n                {\n                    if (l[j] != '0')\n                    {\n                        return false;\n                    }\n                }\n            }\n            else\n            {\n                if (l[j] != '0')\n                {\n                    return false;\n                }\n            }\n            st.pop();\n        }\n        return true;\n    }\n};\nint main()\n{\n\n    string s;\n    cin >> s;\n    string l;\n    cin >> l;\n    Solution ob;\n    cout << ob.canBeValid(s, l) << endl;\n}",
        "wrongcodefile" : "5wrongcode.cpp",
        "rightcodefile" : "5rightcode.cpp"
    }
]