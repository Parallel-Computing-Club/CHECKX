[
    {
        "questionid" : "1",
        "difficulty":"1Easy",
        "description":"<p>&nbsp;Given an expression string <strong>x</strong>. Examine whether the pairs and the orders of &ldquo;{&ldquo;,&rdquo;}&rdquo;,&rdquo;(&ldquo;,&rdquo;)&rdquo;,&rdquo;[&ldquo;,&rdquo;]&rdquo; are correct in exp.<br />For example, the function should return 'true' for exp = &ldquo;[()]{}{[()()]()}&rdquo; and 'false' for exp = &ldquo;[(])&rdquo;.<br></br><hr><p><strong>Example 1:</strong></p><strong>Input</strong>   :  {([])}<br><strong>Output </strong> :  true<br><strong>Explanation</strong> : { ( [ ] ) }.&nbsp;Same kind of brackets can form balaced pairs, with <br>0 number of unbalanced bracket.<p></p></p><p><br><hr><strong>Exapmle 2 :</strong><br><strong>Input</strong> : ()<br><strong>Output </strong> : true<br><strong>Explanation </strong> : (). Same bracket can form balanced pairs,and here <br>only 1 type of bracket is present and in<br>balanced way<p></p><br><hr><p><strong>Example 3:</strong></p><strong>Input </strong> : ([]<br><strong>Output  </strong> : false<br><strong>Explanation </strong> : ([]. Here square bracket is balanced but the<br> small bracket is not balanced and <br>Hence , the output will be unbalanced.<p></p><br><hr><strong>Constraints:</strong><br />1 &le; |x| &le; 32000<p></p></p>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "1wrongcode.cpp",
        "rightcodefile" : "1rightcode.cpp"
    },
    {
        "questionid" : "2",
        "difficulty":"2Hard",
        "description":"Given a string <strong>S</strong> consisting of only opening and closing curly brackets<strong> '{'</strong> and<strong> '}',</strong>&nbsp;find out the minimum&nbsp;number of reversals required to convert the string into a balanced expression.<br />A reversal means changing <strong>'{'</strong> to <strong>'}'</strong> or vice-versa.<p></p><br><hr><p>Example 1&nbsp;:</strong><strong><br>Input&nbsp;:&nbsp;</strong>S = <strong>{&nbsp;{&nbsp;{&nbsp;}&nbsp;}&nbsp;{&nbsp;{&nbsp;{</strong><strong><br>Output&nbsp;:&nbsp;</strong>&nbsp; 2<strong><br>Explanation</strong>&nbsp;:&nbsp;<br> One way to balance is:<strong>{&nbsp;</strong>{&nbsp;{&nbsp;}&nbsp;}&nbsp;<strong>{&nbsp;}&nbsp;}</strong>. There is no balanced sequence that can be formed in lesser reversals.<br><hr><strong>Exapmle&nbsp; :&nbsp;2 <br>Input</strong>&nbsp;:&nbsp;S = {&nbsp;{&nbsp;}&nbsp;{&nbsp;{&nbsp;{&nbsp;}&nbsp;{&nbsp;{&nbsp;}&nbsp;}&nbsp;{&nbsp;{&nbsp;<strong><br>Output:</strong> -1<strong><br>Explanation</strong>: There's no way we can balancethis sequence of braces.<br><hr><p><strong>Expected Time Complexity:&nbsp;</strong>O(|S|).<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</p><p><strong>Constraints:</strong><br />1 &le; |S| &le; 10<sup>5</sup></p>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "2wrongcode.cpp",
        "rightcodefile" : "2rightcode.cpp"
    },
    {
        "questionid" : "3",
        "difficulty":"3Hard",
        "description":"<p>Given a string<strong> S </strong>delete the characters which are appearing more than once consecutively.</p><br><hr><br><p><strong>Example 1:</strong></p><strong>Input:</strong>S = aabb<strong><br>Output:  </strong>ab <strong><br>Explanation:<br></strong> 'a' at 2nd position isappearing 2nd time consecutively.Similiar explanation for b at 4th position.<br><br><hr><br><p><strong>Example 2:</strong><strong><br>Input</strong> : S = aabaa<strong><br>Output:</strong>  aba <strong><br>Explanation:</strong> 'a' at 2nd position is appearing 2nd time consecutively.'a' at fifth position is appearing 2nd time consecutively.</p><p><strong><br><hr><br>GUID:</strong><br />Code starts from&nbsp; the function <strong>removeConsecutiveCharacter()</strong> which accepts a string as input parameter and <strong>returns</strong> modified string. try and find out a (there could be many) invalid test case which will not work out with this solution for current question&nbsp;</p><p><strong><br><hr>Constraints:</strong><br />1&lt;=|S|&lt;=10<sup>5</sup><br />All characters are lowercase alphabets.</p>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "3wrongcode.cpp",
        "rightcodefile" : "3rightcode.cpp"
    },
    {
        "questionid" : "4",
        "difficulty":"4Hard",
        "description":"<p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p><ul><li>For example, <code>&quot0.1.2.201&quot</code> and <code>&quot192.168.1.1&quot</code> are <strong>valid</strong> IP addresses, but <code>&quot0.011.255.245&quot</code>, <code>&quot192.168.1.312&quot</code> and <code>&quot192.168@1.1&quot</code> are <strong>invalid</strong> IP addresses.</li></ul><p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into </em><code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p><br><hr><p><strong>Example 1:</strong></p><p><strong>Input:</strong> s = &quot25525511135&quot</p><strong>Output:</strong> [&quot255.255.11.135&quot,&quot255.255.111.35&quot]<p><strong><br><hr>Example 2:</strong></p><p><strong>Input:</strong> s = &quot1111&quot</p><p><strong>Output:</strong> [&quot1.1.1.1&quot]</p><br><hr><p><strong>Example 3:</strong></p><p><strong>Input:</strong> s = &quot144&quot</p><p><strong>Output:</strong> [&quot&quot]</p><p><strong>Explanation: size of string is less than 4 so it could not be converted into a valid IP .</strong></p><p><strong></strong></p><p><strong><br><hr>Example 4:</strong></p><p><strong>Input:</strong> s = &quot74574377238232&quot</p><p><strong>Output:</strong> [&quot&quot]</p><p><strong>Explanation: size of string is less greater than 12 so it could not be converted into a valid IP .</strong></p><p><strong></strong></p>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "4wrongcode.cpp",
        "rightcodefile" : "4rightcode.cpp"
    },
    {
        "questionid" : "5",
        "difficulty":"5Hard",
        "description":"<p>&nbsp;</p><p>A parentheses string is a <strong>non-empty</strong> string consisting only of '(' and ')'. It is valid if <strong>any</strong> of the following conditions is <strong>true</strong>:</p><ul><li>It is ().</li><li>It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.</li><li>It can be written as (A), where A is a valid parentheses string.</li></ul><p>You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For <strong>each</strong> index i of locked,</p><ul><li>If locked[i] is '1', you <strong>cannot</strong> change s[i].</li><li>But if locked[i] is '0', you <strong>can</strong> change s[i] to either '(' or ')'.</li></ul><p>Return true <em>if you can make s a valid parentheses string</em>. Otherwise, return false.</p><br><hr><br><strong>Example 1:</strong><strong><br>Input:</strong> s = &quot;))()))&quot;, locked = &quot;010100&quot;<strong><br>Output:</strong> true<strong><br>Explanation:</strong> locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.<br><br><hr><br><p><strong>Example 2:</strong> <strong><br>Input:</strong> s = &quot;()()&quot;, locked = &quot;0000&quot; <strong><br>Output:</strong> true <strong><br>Explanation:</strong> We do not need to make any changes because s is already valid.</p><br><hr><strong>Example 3:</strong><strong><br>Input:</strong> s = &quot;)&quot;, locked = &quot;0&quot;<strong><br>Output:</strong> false<strong><br>Explanation:</strong> locked permits us to change s[0]. Changing s[0] to either '(' or ')' will not make s valid.<br><br><hr><br><p><strong>Constraints:</strong></p><ul><li><code>n == s.length == locked.length</code></li><li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code>s[i]</code> is either <code>'('</code> or <code>')'</code>.</li><li><code>locked[i]</code> is either '0' or 1'.</li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "5wrongcode.cpp",
        "rightcodefile" : "5rightcode.cpp"
    },
    {
        "questionid" : "6",
        "difficulty":"6Medium",
        "description":"<p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p><p>&nbsp;</p><p><strong><br><hr>Example 1:</strong></p><br /><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<strong><br>Output:</strong> 2</pre><p><strong><br><hr>Example 2:</strong></p><pre><strong>Input:</strong> root = [2,null,3,null,4,null,5,null,6]<strong><br>Output:</strong> 5</pre><p>&nbsp;</p><p><strong><br>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "6wrongcode.cpp",
        "rightcodefile" : "6rightcode.cpp"
    },
    {
        "questionid" : "7",
        "difficulty":"7Medium",
        "description":"<p>Given a string <code>s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is <strong>the smallest in lexicographical order</strong> among all possible results.</p><p>&nbsp;</p><p><strong><br><hr>Example 1:</strong></p><pre><strong>Input:</strong> s = \"bcabc\"<strong><br>Output:</strong> \"abc\"</pre><p><strong><br><hr>Example 2:</strong></p><pre><strong>Input:</strong> s = \"cbacdcbc\"<strong><br>Output:</strong> \"acdb\"</pre><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> consists of lowercase English letters.</li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "7wrongcode.cpp",
        "rightcodefile" : "7rightcode.cpp"
    },
    {
        "questionid" : "8",
        "difficulty":"8Medium",
        "description":"<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if they are equal when both are typed into empty text editors</em>. <code>'#'</code> means a backspace character.</p><p>Note that after backspacing an empty text, the text will continue empty.</p><p>&nbsp;</p><p><strong><br><hr>Example 1:</strong></p><pre><strong><br>Input:</strong> s = \"ab#c\", t = \"ad#c\"<strong><br>Output:</strong> true<strong><br>Explanation:</strong> Both s and t become \"ac\".</pre><p><strong><br><hr>Example 2:</strong></p><pre><strong><br>Input:</strong> s = \"ab##\", t = \"c#d#\"<strong><br>Output:</strong> true<strong><br>Explanation:</strong> Both s and t become \"\".</pre><p><strong><br><hr>Example 3:</strong></p><pre><strong><br>Input:</strong> s = \"a#c\", t = \"b\"<strong><br>Output:</strong> false<strong><br><hr>Explanation:</strong> s becomes \"c\" while t becomes \"b\".</pre><p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 30</span></code></li><li><code>s</code> and <code>t</code> only contain lowercase letters and <code>'#'</code> characters.</span></li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "8wrongcode.cpp",
        "rightcodefile" : "8rightcode.cpp"
    },
    {
        "questionid" : "9",
        "difficulty":"9Medium",
        "description":"<p>Given string num representing a non-negative integer <code>num</code>, and an integer <code>k</code>, return <em>the smallest possible integer after removing</em> <code>k</code> <em>digits from</em> <code>num</code>.</p><p>&nbsp;</p><p><strong><br><hr>Example 1:</strong></p><pre><strong><br>Input:</strong> num = \"1432219\", k = 3<strong><br>Output:</strong> \"1219\"<strong><br>Explanation:</strong> Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</pre><p><strong><br><hr>Example 2:</strong></p><pre><strong><br>Input:</strong> num = \"10200\", k = 1<strong><br>Output:</strong> \"200\"<strong><br>Explanation:</strong> Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</pre><p><strong><br><hr>Example 3:</strong></p><pre><strong><br>Input:</strong> num = \"10\", k = 2<strong><br>Output:</strong> \"0\"<strong><br>Explanation:</strong> Remove all the digits from the number and it is left with nothing which is 0.</pre><p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= k &lt;= num.length &lt;= 100</code></li><li><code>num</code> consists of only digits.</li><li><code>num</code> does not have any leading zeros except for the zero itself.</li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "9wrongcode.cpp",
        "rightcodefile" : "9rightcode.cpp"
    },
    {
        "questionid" : "10",
        "difficulty":"10Medium",
        "description":"<p>Given a alphanumeric string <code>s</code> of lower , upper case English letters ans numbers.</p<p>A good string is a string which doesn't have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li></ul><p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p><p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p><p><strong>Notice</strong> that an empty string is also good.</p><p>&nbsp;</p><p><strong><br><hr>Example 1:</strong></p><pre><strong><br>Input:</strong> s = \"leEeetcode\"<strong><br>Output:</strong> \"leetcode\"<strong><br>Explanation:</strong> In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\".</pre><p><strong><br><hr>Example 2:</strong></p><pre><strong><br>Input:</strong> s = \"1abBA6cC\"<strong><br>Output:</strong> \"16\"<strong><br>Explanation:</strong> We have many possible scenarios, and all <br>lead to the same answer. <br>For example:\"1abBA6cC\" --&gt; \"1aA6cC\" --&gt; \"16cC\" --&gt; \"16\" <br>\"1abBA6cC\" --&gt; \"1abBA6\" --&gt; \"1aA6\" --&gt; \"\"</pre><p><strong><br><hr>Example 3:</strong></p><pre><strong><br>Input:</strong> s = \"s\"<strong><br>Output:</strong> \"s\"</pre><p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> contains only numbers  lower and upper case English letters.</li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "10wrongcode.cpp",
        "rightcodefile" : "10rightcode.cpp"
    },
    {
        "questionid" : "11",
        "difficulty":"11Medium",
        "description":"<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>&nbsp;</p><p><strong>&nbsp;</strong></p><hr /><p><strong>Example 1:</strong></p><pre><strong><br />Input:</strong> n = 4 <br>l1 = [7,2,4,3], <br>  m = 3 <br> l2 = [5,6,4]<strong><br />Output:</strong> [7,8,0,7]</pre><p><strong>&nbsp;</strong></p><hr /><p><strong>Example 2:</strong></p><pre><strong><br />Input:</strong> n = 3 <br> l1 = [2,4,3], m = 3 <br> l2 = [5,6,4]<strong><br />Output:</strong> [8,0,7]</pre><p><strong>&nbsp;</strong></p><hr /><p><strong>&nbsp;</strong></p><p><strong>Example 3:</strong></p><pre><strong><br />Input:</strong> n = 1 <br> l1 = [0],<br> m = 1<br> l2 = [0]<strong><br />Output:</strong> [0]</pre><p>&nbsp;</p><p><strong>&nbsp;</strong></p><p><strong>&nbsp;</strong></p><p><strong><br><hr>Constraints:</strong></p><ul><li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>It is guaranteed that the list represents a number that does not have leading zeros.</li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "11wrongcode.cpp",
        "rightcodefile" : "11rightcode.cpp"
    },
    {
        "questionid" : "12",
        "difficulty":"12Medium",
        "description":"<p>Given a string <code>s</code> containing only three types of characters: <code>'('</code>, <code>')'</code> and <code>'*'</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is <strong>valid</strong></em>.</p><p>The following rules define a <strong>valid</strong> string:</p><ul><li>Any left parenthesis <code>'('</code> must have a corresponding right parenthesis <code>')'</code>.</li><li>Any right parenthesis <code>')'</code> must have a corresponding left parenthesis <code>'('</code>.</li><li>Left parenthesis <code>'('</code> must go before the corresponding right parenthesis <code>')'</code>.</li><li><code>'*'</code> could be treated as a single right parenthesis <code>')'</code> or a single left parenthesis <code>'('</code> or an empty string <code>\"\"</code>.</li></ul><p>&nbsp;</p><p><strong><br />Example 1:</strong></p><pre><strong><br />Input:</strong> s = \"()\"<strong><br />Output:</strong> true</pre><p><strong>&nbsp;</strong></p><hr /><p><strong>Example 2:</strong></p><pre><strong><br />Input:</strong> s = \"(*)\"<strong><br />Output:</strong> true</pre><p><strong>&nbsp;</strong></p><hr /><p><strong>Example 3:</strong></p><pre><strong><br />Input:</strong> s = \"(*))\"<strong><br />Output:</strong> true</pre><p>&nbsp;</p><p><strong>&nbsp;</strong></p><hr /><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code> is <code>'('</code>, <code>')'</code> or <code>'*'</code>.</li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "12wrongcode.cpp",
        "rightcodefile" : "12rightcode.cpp"
    },
    {
        "questionid" : "13",
        "difficulty":"13Medium",
        "description":"<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p>&nbsp;</p><p><strong><br><hr>Example 1:</strong></p><pre><strong><br>Input:</strong> s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]<strong><br>Output:</strong> [\"cats and dog\",\"cat sand dog\"]</pre><p><strong><br><hr>Example 2:</strong></p><pre><strong><br>Input:</strong> s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]<strong><br>Output:</strong> [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]<strong><br>Explanation:</strong> Note that you are allowed to reuse a dictionary word.</pre><p><strong><br><hr>Example 3:</strong></p><pre><strong><br>Input:</strong> s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]<strong><br>Output:</strong> []</pre><p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li><li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li><li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "13wrongcode.cpp",
        "rightcodefile" : "13rightcode.cpp"
    },
    {
        "questionid" : "14",
        "difficulty":"14Medium",
        "description":"<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p>&nbsp;</p><p><strong>&nbsp;</strong></p><hr /><p><strong>Example 1:</strong></p><pre><strong><br />Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]<strong><br />Output:</strong> 6<strong><br />Explanation:</strong>array [0,1,0,2,1,0,1,3,2,1,2,1]. <br>In this case, 6 units of rain water are being trapped.</pre><p><strong>&nbsp;</strong></p><hr /><p><strong>Example 2:</strong></p><pre><strong><br />Input:</strong> height = [4,2,0,3,2,5]<strong><br />Output:</strong> 9</pre><p>&nbsp;</p><p><strong>&nbsp;</strong></p><hr /><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li><li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "14wrongcode.cpp",
        "rightcodefile" : "14rightcode.cpp"
    },
    {
        "questionid" : "15",
        "difficulty":"15Medium",
        "description":"<p>Given the array <code>prices</code> where <code>prices[i]</code> is the price of the <code>ith</code> item in a shop. There is a special discount for items in the shop, if you buy the <code>ith</code> item, then you will receive a discount equivalent to <code>prices[j]</code> where <code>j</code> is the <strong>minimum</strong>&nbsp;index such that <code>j &gt; i</code> and <code>prices[j] &lt;= prices[i]</code>, otherwise, you will not receive any discount at all.</p><p><em>Return an array where the <code>ith</code> element is the final price you will pay for the <code>ith</code> item of the shop considering the special discount.</em></p><p>&nbsp;</p><p><strong><br><hr>Example 1:</strong></p><pre><strong><br>Input:</strong> prices = [8,4,6,2,3]<strong><br>Output:</strong> [4,2,4,2,3]<strong><br>Explanation:</strong>&nbsp;For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.&nbsp;For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.&nbsp;For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.&nbsp;For items 3 and 4 you will not receive any discount at all.</pre><p><strong><br><hr>Example 2:</strong></p><pre><strong><br>Input:</strong> prices = [1,2,3,4,5]<strong><br>Output:</strong> [1,2,3,4,5]<strong><br>Explanation:</strong> In this case, for all items, you will not receive any discount at all.</pre><p><strong><br><hr>Example 3:</strong></p><pre><strong><br>Input:</strong> prices = [10,1,1,6]<strong><br>Output:</strong> [9,0,1,6]</pre><p>&nbsp;</p><p><strong><br><hr>Constraints:</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 500</code></li><li><code>1 &lt;= prices[i] &lt;= 10^3</code></li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "15wrongcode.cpp",
        "rightcodefile" : "15rightcode.cpp"
    }
]